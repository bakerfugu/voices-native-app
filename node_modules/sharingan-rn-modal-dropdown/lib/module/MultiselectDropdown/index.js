import React, { useState, useRef, useEffect } from 'react';
import { TextInput, Surface, Divider, HelperText, Searchbar, Caption, Chip, Text, Avatar, Provider as PaperProvider, DefaultTheme } from 'react-native-paper';
import { View, Dimensions, Platform, FlatList, ActivityIndicator // ScrollView,
} from 'react-native';
import Modal from 'react-native-modal';
import Lo from 'lodash';
import MultiselectItem from '../Components/MultiselectItem';
import { colors, defaultDropdownProps, ITEMLAYOUT } from '../constants';
import styles from '../styles';
import { deviceWidth, deviceHeight } from '../util';
import EmptyList from '../Components/EmptyList';
import PressableTouch from '../Components/PressableTouch';
const theme = { ...DefaultTheme,
  roundness: 2,
  colors: { ...DefaultTheme.colors,
    colors: {
      primary: '#6200ee',
      accent: '#03dac4',
      background: '#f6f6f6',
      surface: '#FFFFFF',
      error: '#B00020',
      text: '#000000',
      onBackground: '#000000',
      onSurface: '#000000',
      placeholder: 'rgba(0,0,0,0.54)',
      disabled: 'rgba(0,0,0,0.26)'
    }
  },
  dark: true
};

const defaultAvatar = require('../assets/ddicon.png');

const MultiselectDropdown = props => {
  const {
    error,
    value,
    label,
    required,
    disabled,
    data,
    onChange,
    floating,
    enableSearch,
    primaryColor = colors.primary,
    elevation,
    borderRadius,
    activityIndicatorColor,
    searchPlaceholder,
    rippleColor,
    helperText,
    errorColor,
    itemTextStyle,
    itemContainerStyle,
    showLoader,
    animationIn = 'fadeIn',
    animationOut = 'fadeOut',
    supportedOrientations = ['portrait', 'landscape'],
    animationInTiming,
    animationOutTiming,
    parentDDContainerStyle,
    emptyListText,
    disableSort,
    enableAvatar,
    avatarSize,
    defaultSortOrder = 'asc',
    chipType = 'flat',
    chipTextStyle = {},
    onBlur,
    emptySelectionText,
    paperTheme,
    textInputStyle,
    chipStyle = {},
    mainContainerStyle,
    underlineColor,
    disableSelectionTick,
    selectedItemTextStyle,
    selectedItemViewStyle,
    removeLabel,
    mode = 'flat'
  } = props; // const [selected, setSelected] = useState<string[]>([]);

  const [selectedItems, setSelectedItems] = useState([]);
  const [labelv, setLabelV] = useState('');
  const [isVisible, setIsVisible] = useState(false);
  const [iconColor, setIconColor] = useState('grey');
  const [options, setOptions] = useState([]);
  const [hasError, setError] = useState(false);
  const [contMeasure, setConMeasure] = useState({
    vx: 0,
    vy: 0,
    vWidth: 0,
    vHeight: 0
  });
  const [dimension, setDimension] = useState({
    dw: deviceWidth,
    dh: deviceHeight
  });
  const [searchQuery, setSearchQuery] = useState('');
  const pViewRef = useRef();
  const listRef = useRef();
  useEffect(() => {
    Dimensions.addEventListener('change', () => {
      setIsVisible(false);
      const {
        width,
        height
      } = Dimensions.get('window');
      setDimension({
        dw: width,
        dh: height
      });
      setIconColor('grey');
    });
    return () => {
      Dimensions.removeEventListener('change', () => {});
    };
  }, []);
  useEffect(() => {
    if (!Lo.isEmpty(data) && value) {
      setLabelV("".concat(value.length, " selected"));
      setSelectedItems(Lo.filter(data, d => value.includes(d.value)));
    }
  }, [value, data]);
  useEffect(() => {
    if (value) {
      setLabelV("".concat(value.length, " selected"));
      setSelectedItems(Lo.filter(data, d => value.includes(d.value)));
    }
  }, [value, data]);
  useEffect(() => {
    if (disabled) {
      setIconColor('lightgrey');
    }
  }, [disabled]);
  useEffect(() => {
    if (isVisible && listRef) {
      listRef.current.flashScrollIndicators();
    }
  }, [isVisible]);
  useEffect(() => {
    if (!disableSort) setOptions(Lo.orderBy(data, ['label'], [defaultSortOrder]));else setOptions(data);
  }, [data, disableSort, defaultSortOrder]);
  useEffect(() => {
    if (required && error) {
      setError(true);
      setIconColor(errorColor);
    } else {
      setError(false);
      setIconColor('grey');
    }
  }, [required, error, errorColor]);

  const onTextInputFocus = () => {
    if (hasError) {
      setIconColor('red');
    } else {
      setIconColor(primaryColor);
    }

    pViewRef.current.measureInWindow((vx, vy, vWidth, vHeight) => {
      const ddTop = vy + vHeight;
      const bottomMetric = dimension.dh - vy;

      if (bottomMetric < 300) {
        setConMeasure({
          vx,
          vy: ddTop - 217,
          vWidth,
          vHeight
        });
      } else {
        setConMeasure({
          vx,
          vy: ddTop,
          vWidth,
          vHeight
        });
      }
    });
    setIsVisible(true);
  };

  const androidOnLayout = () => {
    if (Platform.OS === 'android') {
      pViewRef.current.measureInWindow((vx, vy, vWidth, vHeight) => {
        const ddTop = vy + vHeight;
        const bottomMetric = dimension.dh - vy;

        if (bottomMetric < 300) {
          setConMeasure({
            vx,
            vy: ddTop - 217,
            vWidth,
            vHeight
          });
        } else {
          setConMeasure({
            vx,
            vy: ddTop,
            vWidth,
            vHeight
          });
        }
      });
    }
  };

  const onModalBlur = () => {
    setIsVisible(false);

    if (hasError) {
      setIconColor('red');
    } else {
      setIconColor('grey');
    }

    if (onBlur && typeof onBlur === 'function') onBlur();
  };

  const handleOptionSelect = v => {
    if (onChange && typeof onChange === 'function') {
      if (value.includes(v)) {
        onChange(Lo.remove(value, s => s !== v));
      } else {
        onChange([...value, v]);
      }

      if (hasError) {
        setIconColor('red');
      } else {
        setIconColor('grey');
      }
    }

    setSearchQuery('');
    if (!disableSort) setOptions(Lo.orderBy(data, ['label'], [defaultSortOrder]));else setOptions(data);
  };

  const onChangeSearch = query => {
    setSearchQuery(query);

    if (!Lo.isEmpty(data) && query) {
      const lFilter = data.filter(opt => opt.label.toString().toLowerCase().trim().includes(query.toString().toLowerCase()));

      if (lFilter.length === 0) {
        setOptions([]);
      } else {
        setOptions(lFilter);
      }
    } else if (!Lo.isEmpty(data) && !query && !disableSort) {
      setOptions(Lo.sortBy(data, 'label'));
    } else setOptions(data);
  };

  const removeChip = rmV => {
    if (!showLoader) {
      if (onChange && typeof onChange === 'function') {
        onChange(Lo.remove(value, s => s !== rmV));
      }
    }
  };

  const getEmptyComponent = () => {
    if (typeof emptyListText === 'string') return /*#__PURE__*/React.createElement(EmptyList, {
      emptyItemMessage: emptyListText
    });else return /*#__PURE__*/React.createElement(React.Fragment, null, emptyListText);
  };

  const labelAction = () => {
    if (removeLabel) {
      return '';
    } else {
      return required ? "".concat(label, "*") : label;
    }
  };

  return /*#__PURE__*/React.createElement(PaperProvider, {
    theme: paperTheme || theme
  }, /*#__PURE__*/React.createElement(View, null, /*#__PURE__*/React.createElement(PressableTouch, {
    onPress: onTextInputFocus,
    disabled: disabled,
    rippleColor: rippleColor
  }, /*#__PURE__*/React.createElement(View, {
    style: [styles.fullWidth, mainContainerStyle],
    ref: pViewRef,
    onLayout: androidOnLayout,
    pointerEvents: "none"
  }, /*#__PURE__*/React.createElement(TextInput, {
    label: labelAction(),
    value: labelv,
    style: [styles.textInput, textInputStyle],
    underlineColor: underlineColor,
    underlineColorAndroid: underlineColor,
    editable: false,
    error: hasError,
    disabled: disabled,
    theme: {
      colors: {
        primary: primaryColor,
        error: errorColor
      }
    },
    right: /*#__PURE__*/React.createElement(TextInput.Icon, {
      name: "menu-down",
      size: 30,
      color: iconColor
    }),
    mode: mode
  })), required && hasError ? /*#__PURE__*/React.createElement(HelperText, {
    type: "error",
    theme: {
      colors: {
        error: errorColor
      }
    },
    visible: hasError
  }, helperText ? helperText : "".concat(label, " is required")) : null), /*#__PURE__*/React.createElement(FlatList, {
    data: selectedItems,
    style: styles.chipScrollView,
    horizontal: true,
    keyExtractor: () => Math.random().toString(),
    renderItem: ({
      item
    }) => /*#__PURE__*/React.createElement(View, {
      style: styles.chipWrapper
    }, /*#__PURE__*/React.createElement(Chip, {
      mode: chipType,
      style: [styles.chip, {
        borderColor: primaryColor,
        backgroundColor: chipType === 'flat' ? primaryColor : 'transparent'
      }, chipStyle],
      ellipsizeMode: "tail",
      onClose: () => removeChip(item.value),
      avatar: enableAvatar && /*#__PURE__*/React.createElement(View, {
        style: styles.textView
      }, /*#__PURE__*/React.createElement(Avatar.Image, {
        size: avatarSize,
        style: styles.avatarView,
        source: item.avatarSource || defaultAvatar
      }))
    }, /*#__PURE__*/React.createElement(Text, {
      style: chipTextStyle
    }, item.label)))
  }), /*#__PURE__*/React.createElement(Modal, {
    isVisible: isVisible,
    onBackdropPress: onModalBlur,
    backdropColor: floating ? 'rgba(0,0,0,0.1)' : 'transparent',
    style: styles.modalStyle,
    animationIn: animationIn,
    animationOut: animationOut,
    animationInTiming: animationInTiming,
    animationOutTiming: animationOutTiming,
    supportedOrientations: supportedOrientations
  }, /*#__PURE__*/React.createElement(View, {
    style: {
      backgroundColor: 'transparent',
      width: !floating ? contMeasure.vWidth : 'auto',
      left: !floating ? contMeasure.vx : 0,
      top: !floating ? contMeasure.vy : 100,
      right: 0,
      position: 'absolute',
      padding: floating ? 20 : 0
    }
  }, /*#__PURE__*/React.createElement(Surface, {
    style: [styles.multiSelectSurface, parentDDContainerStyle, {
      elevation,
      borderRadius
    }, floating ? {
      maxHeight: dimension.dh / 2
    } : null]
  }, showLoader ? /*#__PURE__*/React.createElement(View, {
    style: [styles.loader, {
      borderRadius
    }]
  }, /*#__PURE__*/React.createElement(ActivityIndicator, {
    size: "small",
    color: activityIndicatorColor
  })) : null, /*#__PURE__*/React.createElement(View, null, /*#__PURE__*/React.createElement(FlatList, {
    data: selectedItems,
    style: styles.chipScrollView,
    horizontal: true,
    keyExtractor: () => Math.random().toString(),
    renderItem: ({
      item
    }) => /*#__PURE__*/React.createElement(View, {
      style: styles.chipWrapper
    }, /*#__PURE__*/React.createElement(Chip, {
      mode: chipType,
      style: [styles.chip, {
        borderColor: primaryColor,
        backgroundColor: chipType === 'flat' ? primaryColor : 'transparent'
      }, chipStyle],
      ellipsizeMode: "tail",
      avatar: enableAvatar && /*#__PURE__*/React.createElement(View, {
        style: styles.textView
      }, /*#__PURE__*/React.createElement(Avatar.Image, {
        size: avatarSize,
        style: styles.avatarView,
        source: item.avatarSource || defaultAvatar
      })),
      onClose: () => removeChip(item.value)
    }, /*#__PURE__*/React.createElement(Text, {
      style: chipTextStyle
    }, item.label))),
    ListEmptyComponent: /*#__PURE__*/React.createElement(Caption, null, emptySelectionText)
  })), /*#__PURE__*/React.createElement(Divider, {
    style: styles.divider
  }), /*#__PURE__*/React.createElement(FlatList, {
    ref: listRef,
    data: options,
    initialNumToRender: 25,
    maxToRenderPerBatch: 25,
    persistentScrollbar: true,
    scrollEnabled: !showLoader,
    ListHeaderComponent: enableSearch ? /*#__PURE__*/React.createElement(View, null, /*#__PURE__*/React.createElement(Searchbar, {
      placeholder: searchPlaceholder,
      onChangeText: onChangeSearch,
      value: searchQuery,
      theme: {
        colors: {
          primary: primaryColor
        }
      },
      style: {
        elevation: 0,
        backgroundColor: showLoader ? 'transparent' : '#FFFFFF',
        height: ITEMLAYOUT
      }
    }), /*#__PURE__*/React.createElement(Divider, {
      style: styles.divider
    })) : null,
    stickyHeaderIndices: enableSearch ? [0] : undefined,
    renderItem: ({
      item
    }) => /*#__PURE__*/React.createElement(MultiselectItem, {
      item: item,
      onSelect: handleOptionSelect,
      selected: value,
      selectedColor: primaryColor,
      itemTextStyle: itemTextStyle,
      itemContainerStyle: itemContainerStyle,
      rippleColor: rippleColor,
      disabled: showLoader,
      enableAvatar: enableAvatar,
      avatarSize: avatarSize,
      disableSelectionTick: disableSelectionTick,
      selectedItemTextStyle: selectedItemTextStyle,
      selectedItemViewStyle: selectedItemViewStyle
    }),
    keyExtractor: () => Math.random().toString(),
    ItemSeparatorComponent: () => /*#__PURE__*/React.createElement(Divider, {
      style: styles.divider
    }),
    getItemLayout: (_d, index) => ({
      length: ITEMLAYOUT,
      offset: ITEMLAYOUT * index,
      index
    }),
    ListEmptyComponent: getEmptyComponent()
  }))))));
};

MultiselectDropdown.defaultProps = defaultDropdownProps;
export default MultiselectDropdown;
//# sourceMappingURL=index.js.map